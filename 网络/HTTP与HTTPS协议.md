[TOC]

# HTTP与HTTPS协议

## 一、前置知识

### 1、序列化与反序列化

> **把对象转换为字节序列**的过程称为序列化，**把字节序列恢复为对象**的过程称为反序列化。

序列化能够在传递和保存对象时，保证对象的**完整性**和**可传递性**。将对象转换为有序字节流，以便**在网络上传输**或者**保存在本地文件**中。

### 2、DNS

> 即域名服务器(Domain Name Server)，是**进行域名和对应ip地址转换**的服务器。域名相比ip能够提供给用户更多的有效信息。
>
> DNS服务基于**UDP协议**，使用**53号端口**。

当使用域名访问网站时，会经历：

1. 输入域名。
2. DNS解析成ip地址。
3. 访问IP地址。
4. 完成访问。

> 注：一台计算机上面可以有好多个服务，因此一个ip地址可以对应多个域名，而一个域名只能对应一个ip。
>

### 3、URI与URL

> URI，即统一资源标识符(Uniform Resource Identifier)，是用来唯一地标识一个资源的字符串。
>
> URL，即统一资源定位器(Uniform Resource Locator)，能够唯一地标识一个资源，同时提供了访问该资源的位置与方法。
>
> URL是URI的子集。

URL的一般语法格式为：

`protocol://hostname[:port]/path/[;parameters][?query]#fragment`

①protocol：用来访问资源的**协议名称**。最常用的是http和https协议。

②hostname：是指存放资源的服务器的**域名或 IP 地址**。

③port：端口号。http缺省工作在80端口，https缺省工作在443端口

> 注：默认的众所周知的协议对应的端口号是确定的

④path：由零或多个“/”符号隔开的字符串，一般用来表示资源在主机上相对于工作根目录的路径。

#### 补充：URL编码

> URL编码，又叫做百分号编码，是统一资源定位(URL)的编码方式。

URL规定：对于常用的数字，字母可以直接使用，另外一批作为特殊用户字符也可以直接用，比如`/,:@`等。

剩下的其它所有字符使用UTF-8编码，将**每个字节转成十六进制数x**，然后以`%x1 %x2 ...` 的形式将字符进行编码处理。

 

## 二、HTTP协议

> HTTP，即超文本传输协议(Hyper Text Transfer Protocol)。它是一种`请求-响应式`应用层协议，建立在TCP/IP协议之上。
>

HTTP具有以下特点：

1、无连接：服务器收到客户端请求，完成响应并收到客户端的应答后就会断开连接，即每次连接只处理一个请求，从而节省传输时间。

2、无状态：协议对于事务处理没有记忆能力，当客户端给服务器发送 HTTP 请求时，服务器根据请求，会给客户端发送数据，但是该过程服务器不会记录任何信息。这种方式解放了服务器，但是增加了数据的传输量，因为每次都要发送重复的信息。为了弥补这一不足，产生了**cookie**和**session**这两项记录http状态的技术。

### 1、HTTP请求报文

<img src="https://typora-1307604235.cos.ap-nanjing.myqcloud.com/typora_img/202208090019906.jpg" alt="img" style="zoom:150%;" /> 

- 请求行：包括**请求方法**、**请求URL**以及**http版本**

> 注：<font color=red>请求URI的最大长度为2048</font>

- 报文首部：每一行以 `属性名: 属性值(注意中间是冒号+空格)` 的方式进行信息的陈列，服务器依据此来获取客户端的信息。

- 空白行：用来分隔报头和报文主体

- 报文主体：以**键值对**的形式传递**请求参数**。

### 2、HTTP响应报文

<img src="https://typora-1307604235.cos.ap-nanjing.myqcloud.com/typora_img/202208090019912.jpg" alt="img" style="zoom:150%;" /> 

- 响应行：包括http协议版本以及状态码信息。

> 注：HTTP的请求报文和响应报文都含有HTTP版本，这是服务器应对不同版本客户端的表现。


- 响应首部：返回服务器的一些基本信息

- 空白行：用来分隔报头和报文主体

- 响应主体为客户端请求的具体数据，一般网页请求返回的都是html文件的内容。

### 3、HTTP报文首部字段

#### I. 请求首部的常见字段

1. Host：服务端主机的域名及端口号，常用于服务器配置了多台虚拟主机的情况。
2. User-Agent：客户端及操作系统的名称、版本等信息
3. Accept：指定客户端能够接受的数据类型
4. Accept-Charset：指定客户端能够接受的字符编码集
5. Accept-Language：指定客户端能够接受的语言(中文、英文等)
6. Accept-Encoding：指定客户端能够接受的内容编码以及优先级
7. Cache-Control：指定缓存机制
8. Cookie：服务端通过Set-Cookie返回给客户端的cookie

#### II. 响应首部的常见字段

1. Date：服务器端消息发出的时间
2. Server：HTTP服务器的名称
3. Location：提供重定向后的URL
4. Set-Cookie：服务端向客户端发送cookie

#### III. 实体首部的常见字段

> 实体首部，即请求和响应首部都可以包含的字段

1. Content-Type：主体的类型
2. Content-Length：主体的长度
3. Content-Encoding：主体的编码
4. Allow：支持的HTTP方法

### 4、请求方法

http1.0只有*GET、POST和HEAD*方法，在http1.1版本又新增5种：*OPTIONS、PUT、DELETE、TRACE、CONNECT* 。

#### I. GET 

使用GET方法提交的请求会将所有的**参数拼接到URL的后面**，构成请求行中的请求URL。在浏览器上，这些参数也是会回显在URL上的，因此GET方法对用户提交的密码等信息处理的**不够私密**。

此外，由于参数是通过URL提交的，而**URL最大长度为2KB**，因此GET方法能提交的参数量较小。

![img](https://typora-1307604235.cos.ap-nanjing.myqcloud.com/typora_img/202208090019908.jpg) 

![img](https://typora-1307604235.cos.ap-nanjing.myqcloud.com/typora_img/202208090019909.jpg) 

#### II. POST

POST方法提交的数据不会回显在浏览器URL上，也不会出现在请求URL，而是会**以请求正文的形式**提交给服务器。

因此，POST**私密性更好**，且由于是通过正文传递参数，**可提交的数据量更大**。

![img](https://typora-1307604235.cos.ap-nanjing.myqcloud.com/typora_img/202208090019910.jpg) 

![img](https://typora-1307604235.cos.ap-nanjing.myqcloud.com/typora_img/202208090019911.jpg) 

##### GET与POST对比

1. 它们都是**不安全**的，因为都没有加密措施。
2. GET通常用来**获取数据**，也可以用来提交不涉及私密信息的参数。
3. POST通常用来**提交数据**。

#### III. HEAD

HEAD方法只获取报文的头部信息，用于查看资源是否存在、大小等信息。

![image-20220809113133919](https://typora-1307604235.cos.ap-nanjing.myqcloud.com/typora_img/202208091131024.png)

#### IV. OPTIONS

用来查询"获取指定URL所支持的请求方法"。

#### V. PUT

用来上传文件，由于不自带验证机制，因此需要配合验证程序使用，否则会导致任何人都可以上传文件。

#### VI.DELETE

与PUT相反，用来删除文件，同样不带验证机制。

#### VII.TRACE

可用于测试请求在到达服务器前经过了几个代理服务器。由于容易引发"跨站追踪"攻击，因此不怎么使用。

#### VIII.CONNECT

开启一个客户端与所请求资源之间的双向沟通的通道。

### 5、状态码

- **1XX**：**信息状态码**，表示请求正在被处理

> 100(Continue)：客户端可以继续请求

------

- **2XX**：**成功状态码**，表示请求被正常处理完毕

> 200(OK)：请求成功

------

- **3XX**：**重定向状态码**，表示客户端浏览器需要根据重定向的URL重新发送请求。重定向状态码需要配合Location字段使用，用来指明重定向后的URL。

注：URL重定向，也称为 URL 转发，是一种当实际资源，如单个页面、表单或者整个 Web 应用被迁移到新的 URL 下的时候，<font color=red>**保持原链接可用**</font>的技术。

> 301(Moved Permanently)：永久重定向
>
> 307(Temporary Redirect)：临时重定向
>
> 302(Found)：临时重定向
>
> 注：大多数浏览器在收到302状态码，会将非GET请求方法转换为GET方法，然后重新发起请求。但是对于307状态码，在发起重定向请求时会仍然使用原始请求中的Method。

------

- **4XX**：**客户端错误状态码**，表示服务器无法处理客户端的请求

> 400(Bad Request)：请求报文存在语法错误
>
> 403(Forbidden)：服务器拒绝请求，没有权限访问
>
> 404(Not Found)：服务器找不到请求的网页

------

- **5XX**：**服务器错误状态码**，表示服务器处理请求出错

> 500(Internal Server Error)：表示服务器在执行请求时发生了错误，也有可能是web应用存在的bug或某些临时的错误
>
> 502(Bad Gateway)：Web 服务器作为网关或代理服务器时，从上游服务器收到了无效响应。此类错误一般与服务器本身有关，如CGI应用超时或出错，与请求无关。
>
> 503(Service Unavailable)：表示服务器暂时处于超负载或正在进行停机维护，无法处理请求

 

## 三、HTTPS

> 超文本传输协议安全(HTTP Secure)，是**在HTTP的基础上**，通过**SSL**或**TLS**提供加密处理数据、验证对方身份以及数据完整性保护的协议。

在了解HTTPS之前，需要了解一些加密的方式与概念。

### 1、对称加密

> 对称加密指的是加密和解密使用同一个密钥，该密钥即可以加密又可以解密。
>

优点：**计算量小，速度快**。

缺点：在数据传送前，发送方和接收方**必须商定好秘钥并保存**，才能保证加密的安全性。

### 2、非对称加密

> 非对称加密指的是加密和机密使用一对密钥，分别称为公钥与私钥，公钥用来加密，私钥用来解密。
>

假设A要发送信息给B，那么：

1. B会生成一个公钥和一个私钥
2. B将公钥发送给A
3. A使用该公钥加密

4. B收到密文后，使用自己的私钥解密

优点：即使公钥被拦截，拦截方也无法解密，因此相比对称加密**更加安全**。

缺点：**计算量大，速度慢。**

###  3、数字指纹与数字签名

1. ==发送方==采用**摘要算法**从信息中生成信息摘要，即数字指纹，并**使用私钥对数字指纹进行加密**，从而形成摘要密文，即==数字签名==。

2. ==接收方==采用**同样的摘要算法**生成信息摘要，然后**使用发送方的公钥对数字签名进行解密**，比对自己生成的信息摘要与数字签名解密的结果是否一致，如果一致则说明该证书没有被篡改。

> 注：常见的摘要算法有MD4、MD5，这类算法是将任意长度的数据转化成固定长度的哈希值
>

### 4、SSL与TLS

> SSL，即安全套接字协议层(Secure Socket Layer)，在传输层与应用层之间对网络会话进行加密。
>
> TLS，即安全传输层协议(Transport Layer Security)，是在**SSL3.0**版本的基础上增加了一些新内容而产生的，原理与SSL基本类似。

SSL的主要工作流程为：

1. <font color=red>会话开始前客户端与服务端使用**非对称加密的方式**商议*master_secret*，将其作为**对称加密**的密钥</font>。
2. 客户端和服务端使用master_secret对会话内容进行**对称加密**。

优势在于：

1. 非对称加密交换对称加密的密钥，**安全性较高**。
2. 使用对称加密进行后序的会话，**效率较高**。

![image-20220809124540503](https://typora-1307604235.cos.ap-nanjing.myqcloud.com/typora_img/202208091245553.png)

###  5、HTTPS的基本工作流程

> 由于加入了*SSL/TLS*协议层，因此需要采用非对称加密的方式协商对称加密的密钥：*server*端生成一对公钥和私钥，并将公钥发送给*client*端，由*client*确定对称加密会话的密钥后使用公钥加密发送给*server*端。
>

#### I. 潜在问题分析

server在将公钥发送给client时可能会被窃听者篡改成自己的公钥，后续client将密文发送给server时，由于使用的是窃听者的公钥，因此可以被窃听者的私钥解密，同时窃听者可以使用server原先提供的公钥加密后再发给server端！

#### II. 使用CA证书解决问题

上述问题的根本原因在于：<font color=red>server端发来的公钥无法被证明是否被窃听者篡改</font>。因此，HTTPS引入CA证书对网站和服务器进行身份认证。

> CA证书是服务端向==认证机构(Certification Authority)==提供**营业执照等信息**进行申请，然后由认证机构颁发的**数字证书**，内容包括：
>
> 颁发给哪个网站、<font color=red>server端公钥、数字指纹算法、证书数字签名</font>、颁发时间、颁发机构等信息。
>
> 注：认证机构通过数字指纹算法和私钥生成CA证书的数字签名，该签名可以被内置在浏览器上的公钥解密。

由于公钥被内置在数字证书中，若窃听者将其篡改成自己的公钥，那么client方就能立即分辨出来：

通过证书提供的数字指纹算法生成**摘要**，同时使用**CA认证机构的公钥**对证书的**数字签名**进行解密，并比对**加密结果**和生成的**摘要**是否一致。

- 若一致，则说明证书中的公钥就是server端的公钥，没有被篡改，此时就可以通过该公钥协商对称加密的密钥；

- 若不一致，则说明证书被窃听者篡改，需要采取其他方式重新会话协商密钥！


#### III. 其它可能问题

> 窃听者是否可以将server端的证书直接替换为自己的？
>

可以，但是面临两个问题：

1、申请证书需要提供一系列的**正规文件**。

2、证书中的内容会**暴露**窃听者的相关信息。



## 四、会话跟踪技术

> 会话(session)，指的是web应用程序中从客户端发出请求到服务器响应请求的全过程。

场景:

当用户登录一个页面时，会输入账号密码，然后在该页面点击内容会打开新网页，而这个新网页需要再一次验证用户信息，由于http是无状态的，因此上一次输入的账号密码在该页面需要再输入一次，这给用户带来了不便。

> 会话跟踪就是用于维持客户端多次请求之间数据共享的技术，比如这里的账号密码数据。
>

###  1、Cookie

> *cookie*机制可以用来弥补http无状态的不足，以保持会话跟踪。

*cookie*的工作原理：

1、客户端第一次发送请求至服务端时，服务端会创建*cookie*保存会话信息，*cookie*会添加到响应首部的**Set-Cookie**字段并返回给客户端。

2、客户端收到响应后，下一次访问服务端就会在请求首部的**Cookie**字段中添加该*cookie*，服务器通过不同的*cookie*信息区分不同的用户。

但是，*cookie*由于是存储在客户端，一方面存储的大小是受限的，而且可以查看和修改*cookie*，**不安全**！

因此又引入了新的会话跟踪机制：*session*。

### 2、Session

> *session*保存在服务器上，用户无法查看和修改，因此更加安全可靠。

*session*的工作原理：

1、客户端第一次发送请求至服务端时，服务端会创建一个*session*保存会话信息，同时将一个特殊的*cookie*添加至**Set-Cookie**字段，这个*cookie*包含一个***SessionID***。

2、客户端下一次访问服务端时，就会携带这个包含*SessionID*的**Cookie**字段，服务端根据SessionID查询此前创建的*session*以区分不同的用户。



##  五、HTTP版本

|   版本   | 特性(部分)                                                   |
| :------: | :----------------------------------------------------------- |
| HTTP/0.9 | 组成极其简单，仅支持GET方法和访问静态的html网页              |
| HTTP/1.0 | 新增POST和HEAD方法；增加了请求头和响应头的概念；响应的资源更加丰富；默认使用短连接 |
| HTTP/1.1 | 新增*OPTIONS、PUT、DELETE、TRACE、CONNECT* 方法；**支持范围请求**(即请求资源的一部分) |
| HTTP/2.0 | 使用了**多路复用**技术，增加了传输性能和吞吐量。                                                                                                                  在HTTP和TCP之间加入**二进制分帧层**，将报文分成体量更小的二进制帧，提高传输效率。                                                       **首部压缩**，减小了header的大小。                                                                                                                                             **服务器推送，即一次可以发送多个响应报文**，加快页面的刷新速度。 |

 

## 六、Web页面请求的历程

1. 在浏览器中键入URL。
2. 优先通过浏览器缓存、系统缓存、路由器缓存进行域名到IP地址的转换。其次，向DNS服务器发送请求并从应答报文中获取对应的IP地址。
3. 客户端创建套接字并执行三次握手与服务端建立连接。
4. 浏览器生成请求报文，并逐层向下交付，由TCP、IP层各自添加报头后交给数据链路层和物理层，传输至服务端。
5. 服务端通过逐层解析向上交付给HTTP应用层，并生成对应的响应报文，将请求的页面内容放入响应体。
6. 响应报文再经历向下交付，传输给客户主机，然后向上解析交付给HTTP，最终在浏览器上显示了对应的Web网页。

 

## 七、正向代理与反向代理

### 1、正向代理服务器

正向代理服务器位于客户端和原始服务器之间。

为了从原始服务器取得内容，客户端向代理服务器发送一个请求并指定目标(原始服务器)，然后代理向原始服务器**<font color=red>转交请求并将获得的内容返回给客户端</font>**。

![image-20220809150139862](https://typora-1307604235.cos.ap-nanjing.myqcloud.com/typora_img/202208091502623.png)

#### 正向代理的优点

1. 可以隐藏用户信息，避免用户受到可能的攻击。
2. 可以缓存真实服务器中的数据，提高客户端的访问速度。

### 2、反向代理服务器

反向代理服务器同样位于客户端和原始服务器之间。

客户端并不知道自己要访问具体哪台目标服务器，只知道去访问代理服务器，代理服务器**再将请求分发到各个应用服务器**。

![image-20220809150253768](https://typora-1307604235.cos.ap-nanjing.myqcloud.com/typora_img/202208091502813.png)

#### 反向代理的优点

1. 可以隐藏应用服务器的信息，避免其被直接攻击。
2. 实现负载均衡。反向代理服务器能够将大量的请求**均匀地分派**给它管理的应用服务器，不会出现一台服务器处理大部分请求导致负载过重的情况。因此，某一台服务器挂了，其他服务器也可以正常接收请求。
3. 可以缓存应用服务器中的数据，提高访问速度。

> 注：常见的代理服务器：nginx

 