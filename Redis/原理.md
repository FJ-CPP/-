[TOC]

## Redis为什么这么快

1. Redis是单线程处理请求，避免了线程切换与加锁的消耗（部分情况如持久化到磁盘，需要子进程的参与）。
2. Redis基于Reactor模式，利用I/O多路复用机制能够并发处理大量的客户端请求。
3. Redis的大部分操作在内存中完成。
4. Redis是基于哈希的key-value数据库，增删查改的平均效率为O(1)。
5. Redis使用的数据结构较为简单且高效。
6. Redis实现了自己的虚拟内存(VM)机制，将热数据留在内存，冷数据放在磁盘。

![img](https://typora-1307604235.cos.ap-nanjing.myqcloud.com/typora_img/202208151833598.png)

### 为什么使用单线程

1. Redis大多数都是内存操作，除了存盘使用了多进程方式，其它大部分请求用单线程执行效率是最高的。
2. 避免了锁和线程调度的消耗。



## 过期键的判定与删除策略

> 设置了过期时间的键会被存储在过期字典中，键值为**毫秒精度的**UNIX过期时间戳。

Redis根据以下步骤判断键是否过期：

1. 检查指定键是否存在与过期字典中，如果存在，则取得他的过期时间戳。
2. 判断当前时间戳是否大于过期时间戳，如果是，则键过期，否则，键未过期。

Redis提供了两种删除过期键的策略：

- **惰性删除**：用户访问键时才检查是否过期，过期则删除。

  缺点：对内存不友好，可能导致没被访问的过期键堆积，造成内存泄漏。

- **定期删除**：每隔一段时间执行一次删除过期键的操作，具体步骤为：

  1. 从过期字典中随机选择20个key；
  2. 删除这20个key中已过期的key；
  3. 如果已过期key的比例超过25%，则重复步骤1。



## Redis缓存淘汰策略

1. **LRU(*Least Recently Used*)**：最近最少使用。删除最近没有被使用过的缓存数据。

   问题：可能一个key只是最近偶尔被访问到一次，但是会被LRU算法识别为热数据而留存下去。

2. **LFU(*Least Frequently Used*)**：最近最不经常用。为每个数据增设一个计数器，来记录数据的访问次数。每次优先淘汰访问次数最少的，如果访问次数相同，则像LRU那样根据上一次使用的时间判断。



## 持久化策略

> Redis提供了RDB持久化、AOF持久化、RDB-AOF混合持久化三种持久化策略。
>

### 1、RDB持久化

> RDB持久化是Redis默认持久化方式，可以通过`SAVE或BGSAVE`命令触发，也可以通过配置选项，让服务器在保存条件满足时执行`BGSAVE`命令，最终生成一个二进制RDB文件，文件中保存了数据库中的所有键值对。

- `SAVE`命令会阻塞当前进程，直到RDB文件创建完毕，在此期间服务器无法响应请求。
- `BGSAVE`命令会`fork`一个子进程，让子进程创建RDB文件，父进程继续响应请求。在BGSAVE执行期间，客户端发送的SAVE和BGSAVE请求都会被服务端拒绝。

**RDB持久化的优缺点分析：**

- 优点：RDB文件是一个**经压缩的二进制文件**，**体积小**，使用该文件**恢复数据的速度非常快**。
- 缺点：`BGSAVE`每次运行都要执行fork操作创建子进程，属于重量级操作，**不宜频繁执行**，**无法做到实时持久化**，因此可能会丢失大量数据。

### 2、AOF持久化

> AOF，即Append Only File，文件中保存了服务器执行的所有写命令。

AOF持久化的实现分为三个步骤：**命令追加**、**文件写入**和**文件同步**。

- **命令追加**

AOF功能开启时，服务器在执行完写命令后会将其追加到一个名为`aof_buf`的缓冲区末尾。

- **命令写入**

Redis的服务进程就是一个循环，每当执行到文件事件处理函数时，就会根据配置文件的`appendfsync`选项判断当前是否需要将`aof_buf`的内容写入到AOF文件中，判断方法如下：

![img](https://typora-1307604235.cos.ap-nanjing.myqcloud.com/typora_img/202208162108930.png)

- **文件同步**

即调用系统函数`fsync()或fdatasync()`，强制将文件缓冲区的内容刷新到磁盘。

**AOF重写原理：**

> 随着命令越来越多，AOF文件也会逐渐膨胀。为此，Redis提供了`BGREWRITEAOF命令`执行AOF文件重写的功能。

当执行`BGREWRITEAOF`时，Redis服务端会创建一个子进程，该进程负责直接**读取数据库中的键值对**，生成对应的命令，后期恢复时可以通过该命令生成一个相同的键值对，达到恢复整个数据库的目的。

在子进程重写AOF时，会创建一个AOF重写缓冲区，如果有的`键值对`在重写期间被修改，此时服务器就会将这个修改命令写入到重写缓冲区中，方便子进程实时修改重写的AOF文件。

**AOF持久化的优缺点分析：**

- 优点：与RDB持久化可能丢失大量的数据相比，AOF持久化的**安全性要高很多**。通过使用`everysec`选项，用户可以将数据丢失的时间窗口限制在1秒之内。

- 缺点：

  1. AOF是文本文件，它的**体积要比二进制格式的RDB文件大很多**。
  2. AOF需要通过执行AOF文件中的命令来恢复数据库，其**恢复速度比RDB慢很多**。
  3. 每个写命令会伴随着Redis服务器将命令写入缓冲区的操作，因此会**降低部分性能**。

  > 注：AOF采用文本文件，具有可读性，且避免了二次处理的开销。

### 3、RDB-AOF混合持久化

- 在执行重写AOF文件时，不再根据键值对生成命令，而是生成RDB文件格式的压缩二进制数据。
- 对于执行重写期间的写命令，以文本格式追加到AOF文件末尾，即压缩二进制数据的后面。

通过使用RDB-AOF混合持久化，用户可以同时获得RDB持久化和AOF持久化的优点，服务器既可以通过AOF文件包含的RDB数据来**实现快速的数据恢复操作**，又可以通过AOF文件包含的AOF数据来**将丢失数据的时间窗口限制在1s之内**。













