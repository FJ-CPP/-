[TOC]

# 标准模板库STL

> STL，即标准模板库(Standard Template Library)，是一些常用数据结构和算法模板的集合，主要由6大组成部分组成。

1. **容器(Container)**  

   是一种**数据结构**， 如list, vector, 和deques，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器。

2. **算法（Algorithm）**

   是用来操作容器中的数据的**模板函数**。例如，STL用sort()来对一 个vector中的数据进行排序，用find()来搜索一个list中的对象，函数本身与他们操作的数据的结构和类型无关，因此他们可以用于从简单数组到高度复杂容器的任何数据结构上。

3. **迭代器（Iterator）**

   **提供了访问容器中对象的方法**。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。 迭代器就如同一个指针。事实上，C++ 的指针也是一种迭代器。 但是，迭代器也可以是那些定义了`operator*()`以及其他类似于指针的操作符方法的类对象;

4. **仿函数（Function object）**

   仿函数又称之为**函数对象**， 本质就是重载了`operator()`的类。

5. **适配器（Adaptor）**

   简单的说就是一种**接口类**，专门用来修改现有类的接口，提供一种新的接口，或调用现有的函数来实现所需要的功能。主要包括3中适配器*Container Adaptor、Iterator Adaptor、Function Adaptor*。

6. **空间配制器（Allocator）**

   为STL提供空间配置的系统。其主要工作包括两部分：

   - **对象的创建与销毁**；

   - **内存的获取与释放**。



# 容器

## 1、顺序容器

### I. vector

数据结构：动态数组

特点：

1. 元素在内存中**连续存储**，**支持随机访问**，且访问效率较高。
2. **尾插速度快**，但是头插和中间插入非常耗时，为O(n)（删除同理）。

**resize和reserve的区别：**

1. `reserve(n)`是预留n个元素的空间，**如果n大于当前的capacity**，则开辟一块更大的空间以容纳至少n个元素。但是，对于多出来的这些空间，`reserve`**不会对他们进行初始化**，**对这些区域的访问是非法的**。
2. `resize(n,val)`修改的是容器当前的**size**。如果**n<size**，则将容器当前的**size**缩小至**n**，**多余元素被释放**；如果**n>size**，则向容器中**添加值为val的新元素**，**直到size为n**，**对这些元素的访问时合法的**。

------

### II. list

数据结构：双向链表

特点：

1. 非连续存储，**不支持随机访问**。
2. **在任意位置的增删查改都是O(1)的效率**。

------

### III. deque

数据结构：双端队列(Double End Queue)

> deque的**中控器**存储每个内存块的指针，每个内存块的`cur`记录当前数据的位置，`first`和`last`记录内存块的起始和末尾。

<img src="https://typora-1307604235.cos.ap-nanjing.myqcloud.com/typora_img/202208162305411.png" alt="image-20220816230531293" style="zoom:67%;" />

特点：

1. **支持随机访问**，但由于不是顺序存储，所以性能较vector差一些。
1. **支持头尾的快速插入删除**，但是中间的插入删除性能较差。

## 2、关联容器

### I.map/set

数据结构：红黑树

特点：

1. map存储键值对，set存储键。
2. 增删查改效率为log(n)。
3. 节点根据键值进行**按序存储**。
4. **不允许相同的键值出现**。
5. **map重载了operator[]**用于获取键对应的值。
6. **键不可修改，但是键值可以修改**。

------

### II.multimap/multiset

数据结构：红黑树

特点：

1. multimap存储键值对，multiset存储键。
2. 增删查改效率为log(n)。
3. 节点根据键值进行**按序存储**。
4. **允许相同的键值出现**，但不保证它们之间的相对顺序。
5. **multimap没有重载operator[]**，因为键允许重复。
6. **键不可修改，但是键值可以修改**。

### III. unordered_map/unordered_set

数据结构：哈希表

特点：

1. unordered_map存储键值对，unordered_set存储键。
2. **增删查改的平均时间复杂度为O(1)**。
3. 键值的存储是**无序**的。
4. 键必须是唯一的，不允许重复。
5. **unordered_map重载了operator[]**用于获取键对应的值。

## 3、容器适配器

### I. stack

数据结构：栈，默认封装deque的接口，封装容器可根据传入的模板参数改变

特点：

1. **后进先出**
2. 只允许从栈顶增删查数据。

### II. queue

数据结构：队列，默认封装deque的接口，封装容器可根据传入的模板参数改变

特点：

1. **先进先出**
2. 只允许从队头删查数据，队尾增数据。

### III. priority_queue

数据结构：堆，默认封装vector的接口，封装容器可根据传入的模板参数改变

特点：

1. **最值**存储在堆顶。
2. 只允许从堆顶增删查数据，**不允许改数据**。

## 容器迭代器失效问题

1. 对于顺序容器，如`vector`，删除前面的元素会导致后面元素的迭代器失效，但是可以通过`erase`获取到被删除元素的下一个元素的新迭代器。此外，增加元素可能会导致整个容器的扩容，从而使所有迭代器都失效。

   对于`list`，由于是非顺序存储，因此增删一个节点不会使其他节点的迭代器失效。

   对于`deque`，如果增加元素导致扩充，则会引起所有迭代器失效，因为迭代其内部有指向中控器的指针。其他情况下，对于头尾的插入删除，不会引起迭代器失效，但是对于中间元素的插入删除，会引起对应位置前或后的元素移动，具体哪些迭代器会失效根据当时的内存分布而定。

2. 对于关联容器，如`map/set/multimap/multiset`，底层使用红黑树，是非顺序存储，所以增删一个节点不会使其它迭代器失效。但是它们的`erase`不会返回下一个节点的迭代器。

   但是对于`unordered_map/unordered_set`，底层使用哈希表，增加节点可能会导致整个表的重映射，从而导致所有迭代器失效。



# swap交换两个容器的问题？？？





# 空间配置器

空间配置器是用来实现内存空间分配的工具，与容器联系紧密，每一种容器的空间分配都是通过空间分配器alloctor实现的。

## 1、空间配置器原理

空间配置器有两级结构，第一级用于处理128字节以上的大内存，其余小内存由第二级处理。

### I. 第一级

直接使用malloc和free**向系统申请和释放内存**。

### II. 第二级

维护了一个**内存池**，内存池中存有16种不同大小的内存块(128/8)，用于适应不同的内存需求。

## 2、空间配置器的优势

1. 内存池的介入能够极大地提高内存分配与回收的效率。
2. 更方便维护和管理内存块。



[TOC]

# BST的删除操作

1. 查找到要删除的节点。
2. 如果待删除的节点是叶子节点，则直接删除。
3. 如果待删除的节点不是叶子节点，则先找到待删除节点的**中序遍历的后继节点**，用该后继节点的值替换待删除的节点的值，然后删除后继节点。

# AVL树

> AVL树：在插入或删除时通过一次或多次旋转保证整棵树平衡的二叉搜索树。
>
> 平衡因子：左树与右树的高度差，如果满足平衡，则每个节点的平衡因子都为1、-1或0中的任意一个值，即高度差不超过1。

## AVL树与红黑树的区别

- AVL树由于**严格维持平衡**，更适合**查找密集型**的业务逻辑，但是其代码的调试与维护也更加困难。
- 红黑树适合**插入密集型**业务，且代码也相对容易维护。

## 左旋

![在这里插入图片描述](https://typora-1307604235.cos.ap-nanjing.myqcloud.com/typora_img/202209252049303.png)

## 右旋

![在这里插入图片描述](https://typora-1307604235.cos.ap-nanjing.myqcloud.com/typora_img/202209252049535.png)

## 左右旋

![这里写图片描述](https://typora-1307604235.cos.ap-nanjing.myqcloud.com/typora_img/202209252049550.png)

## 右左旋

![这里写图片描述](https://typora-1307604235.cos.ap-nanjing.myqcloud.com/typora_img/202209252049567.png)



[TOC]

# 红黑树

## 特性

1. 每个节点都被标记成黑色或是红色，其中整棵树的**根节点必然是黑色**
2. 每个红色节点的子节点必然是黑色，即**不能存在连续的红色节点**
3. 红黑树的叶子结点是NIL节点（空节点），它们都是**黑色**
4. **从任意节点出发，到该节点的所有后代叶子结点的每一条路径都包含相同数目的黑色节点**

> 最长路径:包含红色节点最多的路径，也就是"一黑一红"最多的路径
> 最短路径:在最长路径的基础上，去掉所有的红色节点

因此，最长路径最多是最短路径的两倍，当树的高度为n时，将保证时间复杂度为`[logn, 2*logn]`。

> 红黑树核心在于节点颜色的调整，并在必要的时候进行旋转，以维持红黑树的性质。

## 旋转操作

> 旋转操作(Rotate)的目的是使节点颜色符合定义，让RBTree的高度达到近似平衡。
>
> Rotate分为left-rotate（左旋）和right-rotate（右旋），区分左旋和右旋的方法是：待旋转的节点从左边上升到父节点就是右旋，待旋转的节点从右边上升到父节点就是左旋。

<img src="https://typora-1307604235.cos.ap-nanjing.myqcloud.com/typora_img/202209252049270.png" alt="image-20220810153409535" style="zoom:80%;" />

## 插入操作

==情况一：如果关注节点是 a，它的叔叔节点 d 是红色==

<img src="https://typora-1307604235.cos.ap-nanjing.myqcloud.com/typora_img/202209252049315.png" alt="img" style="zoom:67%;" />


具体操作为：将关注节点 a 的父节点 b、叔叔节点 d 的颜色都设置成黑色；将关注节点 a 的祖父节点 c 的颜色设置成红色；关注节点变成 a 的祖父节点 c；**跳到情况二或者情况三**。

==情况二：如果关注节点是 a，它的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的右子节点==

<img src="https://typora-1307604235.cos.ap-nanjing.myqcloud.com/typora_img/202209252049332.png" alt="img" style="zoom:67%;" />


具体操作为：关注节点变成节点 a 的父节点 b；围绕新的关注节点b 左旋；**跳到情况三**。

==情况三：如果关注节点是 a，它的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的左子节点==

<img src="https://typora-1307604235.cos.ap-nanjing.myqcloud.com/typora_img/202209252049306.png" alt="img" style="zoom: 67%;" />

具体操作为：围绕关注节点 a 的祖父节点 c 右旋；将关注节点 a 的父节点 b、兄弟节点 c 的颜色互换，**调整结束**。

## 删除操作

### 1. 针对删除节点初步调整

==情况一：如果要删除的节点是 a，它只有一个子节点 b==

<img src="https://typora-1307604235.cos.ap-nanjing.myqcloud.com/typora_img/202209252049346.png" alt="image-20220810175633524" style="zoom: 67%;" />

具体操作为：删除节点 a，并且把节点 b 替换到节点 a 的位置，这一部分操作跟普通的二叉查找树的删除操作一样；节点 a 只能是黑色，节点 b 也只能是红色，其他情况均不符合红黑树的定义。这种情况下，我们把节点 b 改为黑色；调整结束，不需要进行二次调整。

==情况二：如果要删除的节点 a 有两个非空子节点，并且它的后继节点就是节点 a 的右子节点 c==

<img src="https://typora-1307604235.cos.ap-nanjing.myqcloud.com/typora_img/202209252049335.png" alt="image-20220810175858724" style="zoom:67%;" />

具体操作为：如果节点 a 的后继节点就是右子节点 c，那右子节点 c 肯定没有左子树。我们把节点 a 删除，并且将节点 c 替换到节点 a 的位置。这一部分操作跟普通的二叉查找树的删除操作无异；然后把节点 c 的颜色设置为跟节点 a 相同的颜色；如果节点 c 是黑色，为了不违反红黑树的最后一条定义，我们给节点 c 的右子节点 d 多加一个黑色，这个时候节点 d 就成了“红 - 黑”或者“黑 - 黑”；这个时候，关注节点变成了节点 d，第二步的调整操作就会针对关注节点来做。

==情况三：如果要删除的是节点 a，它有两个非空子节点，并且节点 a 的后继节点不是右子节点==

<img src="https://typora-1307604235.cos.ap-nanjing.myqcloud.com/typora_img/202209252049652.png" alt="image-20220810175816249" style="zoom:67%;" />

具体操作为：找到后继节点 d，并将它删除，删除后继节点 d 的过程参照 CASE 1；将节点 a 替换成后继节点 d；把节点 d 的颜色设置为跟节点 a 相同的颜色；如果节点 d 是黑色，为了不违反红黑树的最后一条定义，我们给节点 d 的右子节点 c 多加一个黑色，这个时候节点 c 就成了“红 - 黑”或者“黑 - 黑”；这个时候，关注节点变成了节点 c，第二步的调整操作就会针对关注节点来做。

### 2. 针对关注节点进行二次调整

初步调整之后，关注节点变成了“红 - 黑”或者“黑 - 黑”节点。针对这个关注节点，再分四种情况来进行二次调整。

备注：二次调整是为了让红黑树中不存在相邻的红色节点。

==情况一：如果关注节点是 a，它的兄弟节点 c 是红色的==

<img src="https://typora-1307604235.cos.ap-nanjing.myqcloud.com/typora_img/202209252049757.png" alt="image-20220810175948526" style="zoom:67%;" />


具体操作：围绕关注节点 a 的父节点 b 左旋；关注节点 a 的父节点 b 和祖父节点 c 交换颜色；关注节点不变；继续从四种情况中选择适合的规则来调整。

==情况二：如果关注节点是 a，它的兄弟节点 c 是黑色的，并且节点 c 的左右子节点 d、e 都是黑色的==

<img src="https://typora-1307604235.cos.ap-nanjing.myqcloud.com/typora_img/202209252049772.png" alt="image-20220810180017083" style="zoom:67%;" />


具体操作：将关注节点 a 的兄弟节点 c 的颜色变成红色；从关注节点 a 中去掉一个黑色，这个时候节点 a 就是单纯的红色或者黑色；给关注节点 a 的父节点 b 添加一个黑色，这个时候节点 b 就变成了“红 - 黑”或者“黑 - 黑”；关注节点从 a 变成其父节点 b；继续从四种情况中选择符合的规则来调整。

==情况三：如果关注节点是 a，它的兄弟节点 c 是黑色，c 的左子节点 d 是红色，c 的右子节点 e 是黑色==

<img src="https://typora-1307604235.cos.ap-nanjing.myqcloud.com/typora_img/202209252049816.png" alt="image-20220810180048173" style="zoom:67%;" />


具体操作：围绕关注节点 a 的兄弟节点 c 右旋；节点 c 和节点 d 交换颜色；关注节点不变；跳转到 CASE 4，继续调整。

==情况四：如果关注节点 a 的兄弟节点 c 是黑色的，并且 c 的右子节点是红色的==

<img src="https://typora-1307604235.cos.ap-nanjing.myqcloud.com/typora_img/202209252049766.png" style="zoom:67%;" />


具体操作：围绕关注节点 a 的父节点 b 左旋；将关注节点 a 的兄弟节点 c 的颜色，跟关注节点 a 的父节点 b 设置成相同的颜色；将关注节点 a 的父节点 b 的颜色设置为黑色；从关注节点 a 中去掉一个黑色，节点 a 就变成了单纯的红色或者黑色；将关注节点 a 的叔叔节点 e 设置为黑色；调整结束。

# 哈希

> 哈希表：通过某种哈希函数计算元素的键值，从而确定它的存储位置。
>
> 常见的确定位置的方法：**直接定址法、除留余数法、平方取中法、随机数法**。

## 如何解决哈希冲突

> 哈希冲突：不同关键字通过相同哈希函数计算出相同的哈希地址

1. 线性探测：探查时从地址d开始，首先探查T[d],在探查T[d+1]…直到查到T[m-1]，此后循环到T[0],T[1]…直到探测到空位或T[d-1]为止。此外，删除元素时不能将对应位置置空，而是标记成空闲，否则可能造成后面的数据找不到的情况。

   > 优点：实现简单
   >
   > 缺点：效率较低

2. 二次探测：探查时从地址d开始，首先探查T[d],再探查T[d+1^2^],T[d+2^2^]…，直到探查到空位或者探查到T[d-1]为止。

   > 优点：效率较高
   >
   > 缺点：空间利用率降低

3. 哈希桶，挂链表(拉链法)或红黑树。



