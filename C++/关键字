[TOC]

## 内存对齐

1. 第一个成员在与结构体变量偏移量为0的地址处。

2. 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。

   对齐数 = min{编译器默认对齐数，该成员大小}

   > VS中默认值为8，Linux中无默认对齐数 

   #pragma pack(n)修改默认对齐数为n(一般设为2的m次方)

   #pragma pack()恢复默认对齐数

3. 结构体总大小为**最大对齐数**（每个成员变量都有一个对齐数）的整数倍。

4. 如果嵌套了结构体的情况，嵌套的结构体对齐到**自己的最大对齐数**的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。

> 注：数组的对齐数是min{编译器默认对齐数，元素类型的大小}

### 为什么需要内存对齐

1. 为了移植性︰不是所有的硬件平台都能访问任意地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，比如：有的平台只能在4的倍数处取int，否则会抛出硬件异常。

2. 为了提高效率︰数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问，而对齐的内存访问仅需要一次访问。

> 注：32位下CPU一次能读取4字节，64位下8字节。

## struct位段

1. 位段的成员**必须是整型(**char/int...)

2. 位段的空间上是按照需要以**4个字节**（ int ）或者**1个字节**（ char ）的方式来开辟的，与结构体相比，更省空间。 

3. 位段涉及很多不确定因素，是**不跨平台**的，注重可移植的程序应该避免使用位段。

```
struct A
{
	char      _a : 1;
	short     _b : 2;
	int       _c : 3;
    int        c    ;//无特殊标明，则为原类型大小：4Byte
	long      _d : 4;
	long long _e : 5;
};
```



## union联合体

联合体的成员共用一块内存空间，大小至少为最大成员的大小。

当最大成员大小不是最大对齐数的整数倍时，遵循内存对齐规则将其对齐。

```
union U
{
    char c;
    int i;
};
```



## 柔型数组

结构体中最后一个元素是未知大小的数组，就叫做柔型数组，在C99时正式引入。

如：

```
typedef struct st_type 
{    
	int i;
    int a[0];//柔性数组成员，有些编译器无法编译，则写成：int a[]
}type_a;
```

- 柔型数组的特点

1. 结构中的柔性数组成员前面必须至少一个其他成员。
2. `sizeof` 返回的这种结构大小不包括柔性数组的内存

- 含柔型数组的结构体的大小受柔型数组类型的影响

如：

`struct s2{ char c;	char a[]; };//它的大小为1` 

`struct s1{ char c;	int a[]; };//它的大小为4` 

`struct s { char c;	double arr[]; };//它的大小为8`

- 包含柔性数组成员的结构用malloc函数进行内存的动态分配，并且分配的内存应该大于结构的大小，以适应柔性数组的**预期大小**。

`type_a *p = (type_a*)malloc(sizeof(type_a)+100*sizeof(int));`

**柔型数组的优势**

1. 方便内存释放：如果是结构体嵌套了一个动态开辟的数组的指针，那么当需要释放整个结构体时，需要先释放该结构体内的数组指针指向的动态内存，然后再释放整个结构体，即需要两次free，而柔型数组只需要释放一次结构体就可以了；
2. 连续的内存有利于提高访问速度(**局部性原理**：从内存中的某个位置访问数据，所访问的存储单元都趋于聚集在一个较小的连续区域中)
3. 能够减少内存碎片(柔型数组只有一次动态开辟内存，倘若是结构体嵌套数组指针，那么需要两次动态开辟内存，由于动态开辟时内存的不连续性，即随机在堆上开辟空间(遵循向上增长)，这就导致产生内存碎片)；



## static

1. 修饰局部变量：“延长”其生命周期(本质上改变了修饰变量的存储类型，将其存放至静态区)

2. 修饰全局变量：使其只能在自己所在的源文件内部使用(内部链接属性)，不能被外部源文件引用(一般情况外部源文件利用extern声明该全局变量后就能使用，这是因为全局变量的外部链接属性)

3. 修饰函数：效果与static修饰全局变量相同

> 注：static只是一个修饰符，`static int a` ,这里的a的类型还是int



## static成员

static修饰的类成员包括静态成员变量和静态成员函数。static成员的特性：

1. 静态成员在类内声明，但是**静态成员变量必须在类外定义**，定义时不添加static关键字(`const static`成员可以在类内定义)；

2. 静态成员可以通过成员函数修改（private）或直接修改（public）

3. 静态成员函数存在于代码区，静态成员变量存储在全局数据区，为类的所有对象共享，不属于某一个具体对象，因此**不计入类的内存大小计算**。

4. 静态成员和类的普通成员一样，有访问限定。

5. 公有的静态成员可以通过 `类名::静态成员` 或者 `对象.静态成员` 访问。

6. 静态成员函数没有隐含的this指针，**不能访问任何非静态成员**。
7. 非静态成员可以访问静态成员，
8. 静态成员在整个继承体系里只会存在一份。



## inline

- 用inline修饰的函数称为内联函数，它会在调用函数的地方进行**函数体的展开**，可以**节省时间，提高效率**，但是会导致代码量增大，消耗了更多的内存空间和更多的指令缓存，这是典型的**以空间换时间**的做法。
- **内联函数没有地址**，所以**声明和定义不能分离**，否则会出现链接错误。也就是说： inline 必须与函数定义放在一起才能使函数成为内联，**仅将 inline 放在函数声明前面不起任何作用**。因此，工程中，往往把内联函数放在头文件中定义。
- 内联函数适用于**调用次数较多**，且**函数体语句较少**(最好小于10行)，并且**不存在递归等复杂的逻辑控制语句**的函数，否则编译器会将其视作普通函数。此外，**定义在类中的函数会自动成为内联函数**
- inline对于编译器只是一个建议，编译器会自动优化一些符合要求的简单函数。

> 注：inline函数**在编译期进行函数的展开**，而非预编译，因为它需要进行类型检查。



## register

可以将某个被大量、频繁使用的变量放到寄存器中，提升效率。

目前的编译器大多会自行判断哪些变量需要放在寄存器中

> 注：被存放到寄存器中的变量不可被取址。



## volatile

用于提醒编译器它修饰的变量随时都有可能改变，因此编译后的程序每次需要读取这个变量的时候，都必须从它的物理地址中读取，而写入时也必须将其刷新到对应的物理内存。

如果没有volatile关键字，则编译器可能优化读取和存储，从而使用寄存器或高速缓存中的值。

> 注：在并发编程中，volatile用于保证有序性和可见性。



## const修饰成员函数（常函数）

const修饰的类成员函数称为const成员函数，它的const实际上修饰的是隐含的this指针所指向的对象，即`const classname* this`，表明该成员函数不能对类的任何成员进行修改。

- 被const修饰的成员函数只能由const修饰的对象调用。

- 被const修饰的对象也只能调用被const修饰的成员函数

- 没有const修饰的对象可以调用const修饰的成员函数，因为允许权限的缩小。
- const修饰的成员函数不能调用非const修饰的成员函数，而非const修饰的成员函数可以调用const修饰的成员函数。



## const定义常量与#define定义常量

1. const是关键字，修饰的常量具有明确类型，且有安全检查
2. const常量方便调试，而define是宏，无法调试
3. const常量占有内存，define是宏替换



## typedef和#define定义类型

1. typedef是关键字，具有类型检查，而define是宏
2. typedef有作用域，而define之后的所有代码都可以使用define的类型
3. 在类内,只有typedef之后的代码能够使用该类型
4. typedef可以被子类继承，并且受访问限定符的限制，比如父类私有的typedef类型无法被子类使用。



## default

`A() = default`
用来修饰构造函数、赋值/移动构造函数、赋值/移动赋值运算符重载和析构函数，表示**生成对应函数的默认版本**。



## delete

`A()=delete`

用来修饰构造函数、赋值/移动构造函数、赋值/移动赋值运算符重载和析构函数，表示**不允许生成对应函数**。



## explicit

用来修饰构造函数，表示无法使用隐式类型转换构造本类型的对象，避免类似于`A a = 1`编译成功的情况。



## noexcept

用来修饰任意函数，表示该函数不会抛出异常。



## constexpr

constexpr可以修饰函数参数、函数返回值、变量、类的构造函数、函数模板等，是一种比const更加严格的约束。它修饰的表达式除了具有“运行时常量性”，也具有“编译时常量性”，即constexpr修饰的表达式的值在编译期间可知。



## final

- 修饰虚函数，表示该虚函数无法被重写。
- 修饰类，表示该类无法被继承。



## override

修饰子类的虚函数，表示子类**必须重写**该函数，否则会编译出错(编译期间检测)。



## typename

- 用作模板参数，等价于class。
- 用来告知编译器，将typename后修饰的内容解释为一个类型。

```C++
 template <typename T>
 2 void foo(const T& t)
 3 {
 4     // 声明一个指向某个类型为T::bar的对象的指针
 5     typename T::bar * p;
       // 如果不加typename，则T::bar可以被解释为T作用域中的变量或函数
 6 }
 7  
 8 struct StructWithBarAsType
 9 {
10     typedef int bar;
11 }; 
12  
13 int main()
14 {
15     StructWithBarAsType x;
16     foo(x);
17 }
```

