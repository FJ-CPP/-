[TOC]

## C和C++的区别

C语言是面向过程的语言，力求通过一个过程处理输入以得到输出。

C++是面向对象的语言，具有"封装继承多态"的特性，其中：

- 封装能够向外界隐藏内部实现的细节，更好地保护成员。
- 继承能够扩展当前已有的模块，实现代码的复用。
- 多态体现在一个同名的方法由于条件不同而表现出不同的效果。

此外，C++引入了模板的概念，可复用度高，在此基础上的STL相比C库更加灵活通用。

> 面向过程：根据业务逻辑从上到下写代码。
>
> 面向对象：将数据与函数绑定到一起，进行封装，这样能够更快速的开发程序，减少了重复代码的重写过程。

### extern "C"

由于C和C++在函数符号命名时的不同，导致C程序在调用C++的库时会出现链接错误。而在函数的声明前加上extern "C"的修饰后，该函数就会按照C语言的规则进行编译，此时链接合并符号表的过程就不会出现找不到对应符号的地址的问题了。



## 内存

### 堆和栈的区别

1. 堆由用户自己申请并释放空间，而栈由系统自动分配并释放。
2. 堆在进程地址空间的低地址处，向上(高地址)生长，而栈在高地址处，向下(低地址)生长。
3. 栈空间较小，Linux下一般为8MB，而堆空间相对更大，接近于虚拟内存空间的大小。

### C++常量存放在哪里

1. const定义的局部常量，存储在栈区。
2. const定义的全局变量在编译器仅保存在符号表，在初次使用时存储在代码区。
3. 字面常量，如`123、"hello"`，存储在代码区。

### 如何在栈上动态开辟内存

使用`alloca()`函数。

### operator new 和operator delete

operator new和operator delete是C++提供的全局函数(并非某一个类的成员函数)。

malloc函数会在空间开辟失败的时候返回NULL，而operator new函数是通过`malloc + 空间开辟失败的时候抛出异常`实现的。
new操作符的底层实现就是调用operator new和构造函数。

operator delete在实现上是通过free来释放空间的，和free基本没有区别。

delete操作符的底层实现会先调用析构函数再调用operator delete。

### 定位new

定位new是调用构造函数来初始化一块已分配的内存空间。

```c++
A* p = (A*)operator new(sizeof(A));
new(p)A(1);//定位new
p->~A();
operator delete(p);
```

定位new在实际中一般**配合内存池使用**。因为内存池分配出来的空间没有初始化，所以如果是自定义类型的对象，需要显示调用构造函数进行初始化。

### malloc/free和new/delete的对比

共同点：

- 都是在堆上申请空间。
- 都需要手动释放。

不同点：

- malloc/free是**函数**，new/delete是**操作符。**
- 对于自定义类型，malloc的内存不会初始化，free会直接释放内存；而new的内存会调用构造函数初始化，delete会先调用析构函数再释放内存。
- malloc需要手动计算申请空间的大小，而new直接跟上申请空间的类型即可。
- malloc返回值类型为void\*，使用时需要强转，而new不需要，因为new后跟的就是空间类型。
- malloc申请空间失败时返回NULL，所以需要手动判空，而new申请空间失败会抛出异常，该异常需要我们手动捕获。

### 深拷贝与浅拷贝

浅拷贝：按字节内容拷贝对象，可能会引发内存被释放两次的问题。

深拷贝：先开辟一块新空间，然后再把旧空间的内容复制到新空间。

### 内存溢出（Out Of Memory）

> 内存溢出是指：程序中存在无法回收的内存，或内存需求大于内存供给。

内存溢出的可能原因有：

1. 死递归导致栈溢出。
2. 线程数过多。
3. 内存泄漏，积累到一定程度使得没有足够内存可用。
4. 启动参数内存值设定的过小。

### 内存泄漏（Memory Leak）

> 内存泄漏是指：在堆上动态开辟的内存在使用完毕后没有及时释放。



## 引用

### 什么时候该使用常引用

1. 希望使用引用提高传参效率，但不希望函数内部改变该参数。
2. 常引用能兼容常量(临时变量)作为参数传递的问题。

### 引用和指针的区别

在语法概念上，引用就是一个**别名**，没有独立的内存空间，但在底层实现上，引用是按照指针的方式实现的，所以实际上是有空间的。

具体区别：

1. 引用在概念上定义了一个变量的别名，而指针存储变量的地址

2. 引用必须初始化，指针不必(但建议置空)

3. 引用在初始化时被指定一个对象后，以后都不能改变，而指针可以在任何时候指向任何一个同类型变量

4. `sizeof(引用)`计算的是引用实体的大小，`sizeof(指针)`计算的是指针的大小
5. 引用自加是引用实体加一，指针自加是根据指针步长而定
6. 指针访问指向的变量需要解引用，而引用可以直接访问实体
7. 引用比指针使用起来相对安全(指针指向的对象可以修改，而引用只能有一个实体)



## 操作符重载

- 当重载作为类的成员函数时，最后一个参数是this指针
- 操作符的左操作数是第一个参数，右操作数是第二个参数

基于以上特性，重载`>>和<<`不能声明为成员函数，而要声明为友元函数。

### 不能重载的五个操作符

```
.* 
:: 
sizeof
?: 
.
```



## 异常

### 异常捕获底层原理(栈展开)

1. 若抛出异常，则优先 在当前函数调用栈检查是否有对应类型的catch。
2. 如果没有匹配的catch，则当前函数栈不再继续向下执行，直接退出到上一层函数栈（即上一层函数调用该函数的位置）向下寻找是否有匹配的catch。
3. 如果到达main函数栈依然没有匹配的，则终止程序。
4. 如果找到匹配的catch，则沿着catch子句继续向下执行。

### 异常安全问题

1. 最好不要在构造函数中抛出异常，否则可能导致对象不完整或没有完全初始化 

2. 最好不要在析构函数内抛出异常，否则可能导致资源泄漏(内存泄漏、句柄未关闭等) 

### 异常的优缺点

优点：

- 相比于返回错误码，异常**可以包含更加丰富的错误信息**，帮助定位bug；
- 对于错误码，如果在调用链中深层的函数出现异常，那么需要层层返回，在最外层才能拿到并处理；
- **很多函数不方便使用返回错误码**的方式，比如`T& operator[]()`；
- 很多测试框架都使用异常，这样能更好的使用单元测试等进行白盒的测试。

缺点：

- 异常会**导致程序的执行流出现乱跳**的情况，比如一个函数栈出现的异常，到另一函数栈才进行catch，调试更加困难；
- **异常可能会导致资源泄露、死锁等安全问题**；
- C++标准库的异常体系定义得不好，导致大家各自定义各自的异常体系，非常的混乱；
- 异常会有一些性能的开销，但是在现代硬件速度很快的情况下，基本忽略不计。



## C++四种强制类型转换

### 1、static_cast

- 基本数据类型之间的转换，如：`double->int、char->int`
- 子类到基类的上行转换(安全)

- 基类到子类的下行转换(不安全，可能会越界访问)

- 将`void*`类型的指针转为其他类型指针


### 2、dynamic_cast(唯一一个运行时类型转换)

- 子类指针/引用到父类指针/引用的上行转换(安全)
- 父类指针/引用到子类指针/引用的下行转换(安全)：这种情况**必须建立在父类指针或引用已经接收了子类切片的情况**！否则，dynamic_cast会强转失败并返回0。

### 3、const_cast

- 将const类型的指针或引用转换成非const类型

### 4、reinterpret_cast

- 可以做任意类型的转换，比如将指针或引用强转成不同类型，将指针转换成整型，但是**不保证会不会出问题**。



